# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ForestryPhotoViewer
                                 A QGIS plugin
 View photo fixation of the selection
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-06-30
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Travin Alexzander/Roslesinforg
        email                : Alexzander721@mail.ru
 ***************************************************************************/
"""
import datetime
import json
import os.path
import random
import re
import shutil
import time

import exifread
import processing
from qgis.PyQt.QtCore import QSettings, QTranslator, QVariant, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QMessageBox, QFrame
from qgis.core import (QgsProject,
                       QgsCoordinateReferenceSystem,
                       QgsField,
                       QgsFields,
                       QgsFeature,
                       QgsVectorLayer,
                       QgsWkbTypes,
                       QgsMapLayerType,
                       QgsMapLayer,
                       QgsProperty,
                       Qgis)

from .forestry_Photo_Viewer_dialog import MainWindow, AuxiliaryWindow
from .resources import *


def create_field(slayer):
    """Создание полей"""
    slayer.startEditing()
    if slayer.name() == 'points_xy':
        slayer.dataProvider().addAttributes([QgsField("x_crs", QVariant.Double)]), slayer.updateFields()
        slayer.dataProvider().addAttributes([QgsField("y_crs", QVariant.Double)]), slayer.updateFields()
        slayer.commitChanges()
    elif slayer.dataProvider().fieldNameIndex("Photo") > 0:
        slayer.dataProvider().deleteAttributes([slayer.dataProvider().fieldNameIndex("Photo")])
    slayer.dataProvider().addAttributes([QgsField(f"Photo", QVariant.String)]), slayer.updateFields()


def set_style(slayer):
    """Установка стиля (есть фото или нет) слою: Процесс привязки снимков"""
    slayer.loadNamedStyle(os.path.join(os.path.dirname(__file__), "Style.qml"))


def time_update(output_file, dct):
    """Обновление времени выходных файлов: Замена времени, Создание файла привязки"""
    hour = int(dct['date'][11:13])
    minute = int(dct['date'][14:16])
    second = int(dct['date'][17:19]) + random.randint(9, 14)
    if second > 59:
        minute += 1
        second = int(second - 60)
        if minute > 59:
            hour += 1
            minute = int(minute - 60)
    date = datetime.datetime(year=int(dct['date'][:4]), month=int(dct['date'][5:7]), day=int(dct['date'][8:10]),
                             hour=hour, minute=minute, second=second)
    os.utime(output_file, (time.mktime(date.timetuple()), time.mktime(date.timetuple())))
    os.utime(f"{output_file[:-3]}json", (time.mktime(date.timetuple()), time.mktime(date.timetuple())))


def xy_crs(layer):
    """Добавление во временнный слой информации о координатах точки в МСК"""
    for feature in layer.getFeatures():
        try:
            layer.dataProvider().changeAttributeValues(
                {feature.id(): {layer.dataProvider().fieldNameIndex("x_crs"): feature.geometry().asPoint().x()}})
            layer.dataProvider().changeAttributeValues(
                {feature.id(): {layer.dataProvider().fieldNameIndex("y_crs"): feature.geometry().asPoint().y()}})
        except IndexError:
            pass


def file_json(date_time, output, kv, vd, pvd, x, y, x_crs, y_crs, region, forestry, prforestry):
    """Создание выходного файла json"""
    if int(pvd) > 0:
        vd = f"{vd}00{pvd}"
    dct = {"subrf": 0,
           "subrf_name": f"{region}",
           "ln": 1,
           "ln_name": f"{forestry}",
           "uln": 0,
           "uln_name": f"{prforestry}",
           "luch": 0,
           "luch_name": f"{prforestry}",
           "kv": int(kv),
           "vid": int(vd),
           "punkt": 0,
           "x": x_crs,
           "y": y_crs,
           "latitude": y,
           "longitude": x,
           "gps_lat": y,
           "gps_long": x,
           "gps_accuracy": 0,
           "gps_altitude": 0,
           "gps_bearing": 0,
           "gps_time": "0",
           "azimuth": -1,
           "date": f"{date_time.split(' ')[0].replace(':', '.')} {date_time.split(' ')[1]}",
           "tax_id": "1",
           "tax_name": "Северо-Западный филиал Рослесинфорга",
           "extension": "jpg"}
    with open(f"{output[:-3]}json", "w") as file:
        json.dump(dct, file, ensure_ascii=False)
    time_update(output, dct)


def statement(txt):
    """Заполнение ведомости фотофиксации"""
    txt.insert(0, f"В следующих выделах фотофиксация отсутствует\n")
    txt.insert(1, f"---------------------------------------------\n")
    date = f"{time.localtime(time.time()).tm_hour}{time.localtime(time.time()).tm_min}" \
           f"{time.localtime(time.time()).tm_sec}_{time.localtime(time.time()).tm_mday}" \
           f"{time.localtime(time.time()).tm_mon}{time.localtime(time.time()).tm_year}"
    name = f"{os.path.join(os.path.join(os.environ['USERPROFILE']), 'Desktop')}/Ведомость фотофиксации {date}.txt"
    with open(name, 'w', encoding='cp1251') as file:
        file.writelines(txt)
    os.startfile(f'{name}')


def message(tip, text):
    """Вывод информационного сообщения"""
    error_msg = QMessageBox()
    error_msg.setWindowTitle(tip)
    error_msg.setText(text)
    error_msg.exec_()


class ForestryPhotoViewer:

    def __init__(self, iface):
        self.label = None
        self.step = 0
        self.iface = iface
        self.instance = QgsProject.instance()
        self.plugin_dir = os.path.dirname(__file__)
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'ForestryPhotoViewer_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        self.actions = []
        self.menu = self.tr(u'&forestry Photo Viewer')
        self.first_start = None

    def tr(self, text):
        return QCoreApplication.translate('ForestryPhotoViewer', text)

    def add_action(
            self,
            icon_path,
            text,
            callback,
            enabled_flag=True,
            add_to_menu=True,
            add_to_toolbar=True,
            status_tip=None,
            whats_this=None,
            parent=None):

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToRasterMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        icon_path = ':/plugins/forestry_Photo_Viewer/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Просмотр фотофиксации'),
            callback=self.run,
            parent=self.iface.mainWindow())

        self.key_action = QAction("Test Plugin", self.iface.mainWindow())
        self.iface.registerMainWindowAction(self.key_action, "p")
        self.iface.addPluginToMenu("&Test plugins", self.key_action)
        self.key_action.triggered.connect(self.open_jpg)
        self.first_start = True

    def unload(self):
        for action in self.actions:
            self.iface.removePluginRasterMenu(
                self.tr(u'&forestry Photo Viewer'),
                action)
            self.iface.removeToolBarIcon(action)

    def run(self):
        self.dlg = MainWindow()
        self.value = False
        self.val = 0
        self.label = 0
        self.dlg.path.clear()
        self.choice_layer()
        self.dlg.progressBar.setValue(self.val)
        self.dlg.substitution.setChecked(True)
        self.dlg.layerBox_2.setDisabled(True)
        self.dlg.fields_setting.setDisabled(True)
        self.dlg.sort_1.setDisabled(True)
        self.dlg.sort_2.setDisabled(True)
        self.dlg.fields_setting.clicked.connect(self.setting)
        self.dlg.OK.clicked.connect(self.apply)
        self.dlg.Cancel.clicked.connect(self.cancel)
        self.dlg.import_1.clicked.connect(self.import_file)
        self.dlg.export_1.clicked.connect(self.export)
        self.dlg.button.clicked.connect(self.select_files_jpg)
        self.dlg.button_2.clicked.connect(self.select_files_jpg)
        self.dlg.button_3.clicked.connect(self.select_files_jpg)
        self.dlg.substitution.clicked.connect(self.clik_substitution)
        self.dlg.binding.clicked.connect(self.clik_binding)
        self.dlg.directory.clicked.connect(self.dct)
        self.dlg.sort_1.clicked.connect(self.sorting)
        self.dlg.sort_2.clicked.connect(self.sorting)
        self.dlg.tabWidget.setCurrentIndex(0)
        self.dlg.show()
        if QgsMapLayerType.VectorLayer not in [layer.type() for layer in self.instance.mapLayers().values() if
                                               layer.type() == QgsMapLayer.VectorLayer]:
            message("Ошибка", "Проект не содержит векторных слоёв!\n Добавьте слои в проект!")
            self.cancel()

    def choice_layer(self):
        """Заполнение combobox слоями"""
        self.dlg.layerBox_1.clear(), self.dlg.layerBox_2.clear(), self.dlg.layerBox_3.clear()
        [self.dlg.layerBox_1.addItem(layer.name(), layer) for layer in self.instance.mapLayers().values() if
         layer.type() == QgsMapLayer.VectorLayer and layer.wkbType() == 6]
        [self.dlg.layerBox_2.addItem(layer.name(), layer) for layer in self.instance.mapLayers().values() if
         layer.type() == QgsMapLayer.VectorLayer and layer.wkbType() == 6]
        [self.dlg.layerBox_3.addItem(layer.name(), layer) for layer in self.instance.mapLayers().values() if
         layer.type() == QgsMapLayer.VectorLayer and layer.wkbType() == 6]

    def clik_substitution(self):
        """Отклик на галочки"""
        if self.dlg.substitution.isChecked():
            self.dlg.binding.setChecked(False)
            self.dlg.layerBox_2.setDisabled(True)
            self.dlg.fields_setting.setDisabled(True)
        else:
            self.dlg.binding.setChecked(True)
            self.dlg.substitution.setChecked(False)
            self.dlg.layerBox_2.setDisabled(False)
            self.dlg.fields_setting.setDisabled(False)

    def clik_binding(self):
        """Отклик на галочки"""
        if self.dlg.binding.isChecked():
            self.dlg.substitution.setChecked(False)
            self.dlg.layerBox_2.setDisabled(False)
            self.dlg.fields_setting.setDisabled(False)
        else:
            self.dlg.substitution.setChecked(True)
            self.dlg.binding.setChecked(False)
            self.dlg.layerBox_2.setDisabled(True)
            self.dlg.fields_setting.setDisabled(True)

    def select_files_jpg(self):
        """Выбор файлов .jpg для обработки"""
        if os.path.exists(f"{self.plugin_dir}/working files/filenames.json") and os.path.isfile(
                f"{self.plugin_dir}/working files/filenames.json"):
            if time.time() - os.stat(f"{self.plugin_dir}/working files/filenames.json")[7] > 43200:
                os.remove(f"{self.plugin_dir}/working files/filenames.json")
        filenames = QFileDialog.getOpenFileNames(self.dlg, 'Open files', '', '"Файл "jpg" (*.jpg)')[0]
        if len(filenames) > 0:
            self.step = 100 / len(filenames) + 1
        with open(f"{os.path.dirname(__file__)}/working files/filenames.json", "w") as file:
            json.dump(filenames, file)
        if self.dlg.tabWidget.currentIndex() == 0:
            self.dlg.files.setText(f"Выбрано файлов: {len(filenames)}")
            self.label = int(self.dlg.files.text().replace('Выбрано файлов: ', ''))
            if int(self.dlg.files.text().replace('Выбрано файлов: ', '')) > 0:
                self.dlg.sort_1.setDisabled(False)
            else:
                self.dlg.sort_1.setDisabled(True)
        elif self.dlg.tabWidget.currentIndex() == 1:
            self.dlg.files_2.setText(f"Выбрано файлов: {len(filenames)}")
            self.label = int(self.dlg.files_2.text().replace('Выбрано файлов: ', ''))
        elif self.dlg.tabWidget.currentIndex() == 2:
            self.dlg.files_3.setText(f"Выбрано файлов: {len(filenames)}")
            self.label = int(self.dlg.files_3.text().replace('Выбрано файлов: ', ''))
            if int(self.dlg.files_3.text().replace('Выбрано файлов: ', '')) > 0:
                self.dlg.sort_2.setDisabled(False)
            else:
                self.dlg.sort_2.setDisabled(True)

    def sorting(self):
        """Сортировка файлов по лесничествам"""
        with open(f"{os.path.dirname(__file__)}/working files/filenames.json", "r") as file:
            filenames = json.load(file)
            if len(filenames) != 0:
                for filename in filenames:
                    with open(f'{filename[:-3]}json', 'r') as json_file:
                        data = json.load(json_file)
                        if 'uln_name' in data.keys():
                            forestry = data['uln_name']
                        else:
                            forestry = 'Лесничество не указано'
                    file = filename.split('/')[len(filename.split('/')) - 1]
                    path = f"{filename.replace(file, '')}{forestry}"
                    if not os.path.exists(path):
                        os.mkdir(path)
                    os.rename(filename, f"{path}/{file}")
                    os.rename(f"{filename[:-3]}json", f"{path}/{file[:-3]}json")
        if self.dlg.tabWidget.currentIndex() == 0:
            os.remove(f"{self.plugin_dir}/working files/filenames.json")
            self.dlg.files.setText(f"Выбрано файлов: 0")
            self.label = int(self.dlg.files.text().replace('Выбрано файлов: ', ''))
            self.select_files_jpg()
        elif self.dlg.tabWidget.currentIndex() == 2:
            os.remove(f"{self.plugin_dir}/working files/filenames.json")
            self.dlg.files_3.setText(f"Выбрано файлов: 0")
            self.label = int(self.dlg.files_3.text().replace('Выбрано файлов: ', ''))
            self.select_files_jpg()

    def dct(self):
        """Выбор каталога для сохранения выходных файлов"""
        self.dlg.path.setText(QFileDialog.getExistingDirectory())

    def setting(self):
        """Вызов окна для ввода данных для файла привязки"""
        self.wnd = AuxiliaryWindow()
        self.wnd.OKButton.clicked.connect(self.setting_value)
        self.values_remember()
        self.wnd.show()

    def setting_value(self):
        """Проверка пустых значений в полях ввода"""
        if not self.wnd.Subject.text().strip():
            message("Ошибка!", f"Поле {self.wnd.label_1.text()} не заполнено!")
        if not self.wnd.Forestry.text().strip():
            message("Ошибка!", f"Поле {self.wnd.label_2.text()} не заполнено!")
        if not self.wnd.PrForestry.text().strip():
            message("Ошибка!", f"Поле {self.wnd.label_3.text()} не заполнено!")
        if self.wnd.Subject.text().strip() and self.wnd.Forestry.text().strip() and self.wnd.PrForestry.text().strip():
            self.write()
            self.value = True
            self.wnd.close()

    def write(self):
        """Запись значений во внешний файл"""
        if os.path.exists(f"{self.plugin_dir}/working files/values.tmp") and os.path.isfile(
                f"{self.plugin_dir}/working files/values.tmp"):
            with open(f"{self.plugin_dir}/working files/values.tmp", 'w', encoding='cp1251') as file:
                file.writelines(
                    [f"{self.wnd.Subject.text()}\n",
                     f"{self.wnd.Forestry.text()}\n",
                     f"{self.wnd.PrForestry.text()}\n",
                     f"{self.wnd.remember_1.isChecked()}\n",
                     f"{self.wnd.remember_2.isChecked()}\n",
                     f"{self.wnd.remember_3.isChecked()}\n"])

    def values_remember(self):
        """Установка сохранённых значений в поля"""
        self.wnd.Subject.clear(), self.wnd.Forestry.clear(), self.wnd.PrForestry.clear()
        if os.path.exists(f"{self.plugin_dir}/working files/values.tmp") and os.path.isfile(
                f"{self.plugin_dir}/working files/values.tmp"):
            if time.time() - os.stat(f"{self.plugin_dir}/working files/values.tmp")[7] > 43200:
                os.remove(f"{self.plugin_dir}/working files/values.tmp")
        if os.path.exists(f"{self.plugin_dir}/working files/values.tmp") and os.stat(
                f"{self.plugin_dir}/working files/values.tmp").st_size != 0:
            with open(f"{self.plugin_dir}/working files/values.tmp", 'r', encoding='cp1251') as file:
                text = file.readlines()
                if text[3][:-1] == str(True):
                    self.wnd.remember_1.setChecked(True)
                    self.wnd.Subject.setText(text[0][:-1])
                else:
                    self.wnd.remember_1.setChecked(False)
                if text[4][:-1] == str(True):
                    self.wnd.remember_2.setChecked(True)
                    self.wnd.Forestry.setText(text[1][:-1])
                else:
                    self.wnd.remember_2.setChecked(False)
                if text[5][:-1] == str(True):
                    self.wnd.remember_3.setChecked(True)
                    self.wnd.PrForestry.setText(text[2][:-1])
                else:
                    self.wnd.remember_3.setChecked(False)
        elif not os.path.exists(
                f"{self.plugin_dir}/working files/values.tmp") or os.stat(
            f"{self.plugin_dir}/working files/values.tmp").st_size == 0:
            with open(f"{self.plugin_dir}/working files/values.tmp", 'w', encoding='cp1251') as file:
                file.writelines(
                    ["Введите значение\n",
                     f"{self.wnd.remember_1.isChecked()}\n",
                     "Введите значение\n",
                     f"{self.wnd.remember_2.isChecked()}\n",
                     "Введите значение\n",
                     f"{self.wnd.remember_3.isChecked()}\n"])

    def set_crs(self, slayer):
        """Установка для слоёв СК проекта"""
        slayer.setCrs(self.instance.crs())

    def apply(self):
        """Запуск основных процессов обработки"""
        if self.dlg.tabWidget.currentIndex() == 0:
            # Процесс привязки снимков
            if self.label == 0:
                message("Ошибка", "Не выбран не один файл!")
            else:
                create_field(self.dlg.layerBox_1.itemData(self.dlg.layerBox_1.currentIndex()))
                self.val += self.step
                self.dlg.progressBar.setValue(self.val)
                self.fields_check(self.dlg.layerBox_1.itemData(self.dlg.layerBox_1.currentIndex()))
                set_style(self.dlg.layerBox_1.itemData(self.dlg.layerBox_1.currentIndex()))
                self.dlg.progressBar.setValue(100)
                message("Готово", "Фотофиксация привязана!")
                self.cancel()
        elif self.dlg.tabWidget.currentIndex() == 1:
            # Процесс преобразования файлов
            if self.label == 0:
                message("Ошибка", "Не выбран не один файл!")
            elif not self.dlg.path.text():
                message("Ошибка", "Папка назначения не задана!")
            else:
                if self.dlg.substitution.isChecked():
                    # Замена времени
                    self.remember_time()
                    self.dlg.progressBar.setValue(100)
                    message("Готово", "Время в файлах заменено!\n"
                                      f"Изменённая фотофиксация сохранена в {self.dlg.path.text()}")
                    self.cancel()
                elif self.dlg.binding.isChecked():
                    # Создание файла привязки
                    if not self.value:
                        self.setting()
                    elif self.value:
                        self.set_crs(self.dlg.layerBox_2.itemData(self.dlg.layerBox_2.currentIndex()))
                        self.point_centroid(self.dlg.layerBox_2.itemData(self.dlg.layerBox_2.currentIndex()).name())
                        self.point_xy()
                        create_field(self.instance.mapLayersByName("points_xy")[0])
                        xy_crs(self.instance.mapLayersByName("points_xy")[0])
                        self.file_create()
                        self.instance.removeMapLayer(self.instance.mapLayersByName("points_xy")[0])
                        self.instance.removeMapLayer(self.instance.mapLayersByName("points_inaccessibility")[0])
                        self.dlg.progressBar.setValue(100)
                        message("Готово", "Файлы привязки созданы!\n"
                                          f"Фотофиксация сохранена в {self.dlg.path.text()}")
                        self.cancel()
        elif self.dlg.tabWidget.currentIndex() == 2:
            # Процесс создания ведомости фотофиксации
            if self.label == 0:
                message("Ошибка", "Не выбран не один файл!")
            else:
                self.title, self.text = "Готово", "Ведомость фотофиксации сохранена на рабочем столе!"
                self.fields_check(self.dlg.layerBox_3.itemData(self.dlg.layerBox_3.currentIndex()))
                self.dlg.progressBar.setValue(100)
                message(self.title, self.text)
                self.cancel()

    def fields_check(self, slayer):
        """Проверка наличия полей для: Процесс привязки снимков, Процесс создания ведомости фотофиксации"""
        if self.dlg.tabWidget.currentIndex() == 0:
            if 'KV' and 'VID' and 'PV' in slayer.fields().names():
                kvart, videl, podvidel = 'KV', 'VID', 'PV'
                self.photobinding(slayer, kvart, videl, podvidel)
            elif 'KW' and 'VD' and 'PVD' in slayer.fields().names():
                kvart, videl, podvidel = 'KW', 'VD', 'PVD'
                self.photobinding(slayer, kvart, videl, podvidel)
            elif 'KV' and 'SKNR' in slayer.fields().names():
                kvart, videl, podvidel = 'KV', 'SKNR', None
                self.photobinding(slayer, kvart, videl, podvidel)
            else:
                message("Ошибка", "В слое отсутствует поле с информацией о № квартала, выдела или подвыдела!")
        elif self.dlg.tabWidget.currentIndex() == 2:
            if 'KV' and 'SKNR' in slayer.fields().names():
                kv, vd, zk_txt, vmr = 'KV', 'SKNR', 'ZK_txt', 'VMR'
                mtip, dtg, amz1, skal1 = 'MTIP', 'DTG', 'AMZ1', 'SKAL1'
                self.comparison(slayer, kv, vd, zk_txt, vmr, mtip, dtg, amz1, skal1)
            else:
                self.title = "Ошибка"
                self.text = "В слое отсутствуют поля KV, SKNR с информацией о № квартала, выдела!\n" \
                            "Убедитесь, что вы экспортировали верный слой (250 полей) из АРМ"

    def photobinding(self, slayer, kvart, videl, podvidel):
        """Привязкам снимка к слою: Процесс привязки снимков"""
        dct = {}
        with open(f"{os.path.dirname(__file__)}/working files/filenames.json", "r") as file:
            filenames = json.load(file)
            if len(filenames) != 0:
                for filename in filenames:
                    with open(f'{filename[:-3]}json', 'r') as json_file:
                        data = json.load(json_file)
                        kw = data['kv']
                        vid = data['vid']
                        if "00" in str(vid):
                            pvd = int(str(vid).split("00")[1])
                            vid = int(str(vid).split("00")[0])
                        else:
                            pvd = 0
                        if kw != 0 and vid != 0:
                            for feature in slayer.getFeatures():
                                if feature[kvart] == kw and feature[videl] == vid and podvidel is None:
                                    dct.update({f"{data['date']}": filename})
                                    self.photo_check(slayer, feature, data['date'])
                                elif feature[kvart] == kw and feature[videl] == vid and feature[podvidel] == pvd:
                                    dct.update({f"{data['date']}": filename})
                                    self.photo_check(slayer, feature, data['date'])
        self.photo_path(dct)
        slayer.updateFields(), slayer.commitChanges()

    def photo_check(self, slayer, feature, meaning):
        if str(feature['Photo']) != "NULL" and meaning not in str(feature['Photo']):
            meaning = f"{str(feature['Photo'])}; {meaning}"
        try:
            slayer.dataProvider().changeAttributeValues(
                {feature.id(): {
                    slayer.dataProvider().fieldNameIndex('Photo'): meaning}})
            self.val += self.step
            self.dlg.progressBar.setValue(self.val)
        except IndexError:
            pass

    def photo_path(self, dct):
        """Сохранение пути к файлу"""
        if os.path.exists(f"{self.plugin_dir}/working files/photo path.json") and os.path.isfile(
                f"{self.plugin_dir}/working files/photo path.json"):
            if time.time() - os.stat(f"{self.plugin_dir}/working files/photo path.json")[7] > 43200:
                os.remove(f"{self.plugin_dir}/working files/photo path.json")
        with open(f"{os.path.dirname(__file__)}/working files/photo path.json", "w") as file:
            json.dump(dct, file, ensure_ascii=False)

    def open_jpg(self):
        """Открытие привязанного фото по нажатию кнопки"""
        for feat in self.iface.activeLayer().selectedFeatures():
            try:
                if feat["Photo"]:
                    if os.path.exists(f"{self.plugin_dir}/working files/photo path.json") \
                            and os.stat(f"{self.plugin_dir}/working files/photo path.json").st_size != 0:
                        with open(f"{os.path.dirname(__file__)}/working files/photo path.json", "r") as file:
                            filename = json.load(file)
                            for key in feat["Photo"].split('; '):
                                try:
                                    os.startfile(f'{filename[key]}')
                                except FileNotFoundError:
                                    message("Ошибка",
                                            f"Файл:\n "
                                            f"{filename[key]}\n"
                                            "Не найден, возможно он был перемещён или удалён.")
                    else:
                        message("Ошибка", "Выполните фотопривязку!")
                elif not feat["Photo"]:
                    message("Ошибка",
                            "Выбранный выдел не содержит фотофиксации!\n"
                            "Убедитесь в наличии фото для выдела и выполните фотопривязку.")
            except KeyError:
                message("Ошибка",
                        "Выбранный выдел не содержит фотофиксации!\n"
                        "Убедитесь в наличии фото для выдела и выполните фотопривязку.")

    def remember_time(self):
        """Запоминание даты json файла, разделение по датам: Замена времени"""
        day = None
        days_list = []
        time_list = []
        with open(f"{os.path.dirname(__file__)}/working files/filenames.json", "r") as file:
            filenames = json.load(file)
            if len(filenames) != 0:
                for filename in filenames:
                    with open(f"{filename[:-3]}json", "r") as json_file:
                        data = json.load(json_file)['date'].split(" ")
                        if day is None:
                            day = data[0]
                            time_list.append(data[1])
                        elif data[0] == day:
                            time_list.append(data[1])
                        else:
                            days_list.append(time_list)
                            day = data[0]
                            time_list = [data[1]]
                days_list.append(time_list)
        self.change_time(days_list, filenames)

    def change_time(self, days_list, filenames):
        """Изменение исходного времени: Замена времени"""
        variable_time = None
        time_list = []
        for day_time in days_list:
            time_counter = 0
            while time_counter <= len(day_time) - 1:
                if int(day_time[time_counter].split(":")[0]) < 20:
                    if variable_time is None:
                        variable_time = day_time[time_counter]
                    else:
                        random_min = random.randint(10, 20)
                        random_sec = str(random.randint(0, 59))
                        if len(random_sec) == 1:
                            random_sec = f'0{random_sec}'
                        minute = int(variable_time.split(":")[1]) + random_min
                        if len(str(minute)) == 1:
                            minute = f'0{minute}'
                        variable_time = f'{variable_time.split(":")[0]}:{str(minute)}:{random_sec}'
                        if minute > 59:
                            hour = str(int(variable_time.split(":")[0]) + 1)
                            minute = str(minute - 60)
                            if len(minute) == 1:
                                minute = f'0{minute}'
                            variable_time = f'{hour}:{minute}:{random_sec}'
                time_list.append(variable_time)
                time_counter += 1
            variable_time = None
        self.file_write(time_list, filenames)

    def file_write(self, time_list, filenames):
        """Запись нового времени в json файл: Замена времени"""
        if len(filenames) != 0:
            for filename in filenames:
                self.val += self.step
                self.dlg.progressBar.setValue(self.val)
                with open(f"{filename[:-3]}json", "r") as json_file:
                    dct = json.load(json_file)
                    dct.update(date=f"{dct['date'][:10]} {time_list[filenames.index(filename)]}")
                    output_file = f"{self.dlg.path.text()}/{dct['ln']}_{dct['uln']}_{dct['luch']}_{dct['kv']}" \
                                  f"_{dct['vid']}_{dct['date'][:10].replace('.', '')}" \
                                  f"_{time_list[filenames.index(filename)].replace(':', '')}_{dct['tax_id']}.jpg"
                    with open(f"{filename[:-3]}json", "w") as file:
                        json.dump(dct, file, ensure_ascii=False)
                    self.copy_files(filename, output_file)
                    time_update(output_file, dct)

    def copy_files(self, filename, output_file):
        """Копирование исходных файлов в каталог выходных файлов: Замена времени, Создание файла привязки"""
        shutil.copy(filename, output_file)
        if self.dlg.substitution.isChecked():
            shutil.copy(f"{filename[:-3]}json", f"{output_file[:-3]}json")

    def point_centroid(self, layer_name):
        """Создание временного слоя центроидов: Создание файла привязки"""
        self.instance.addMapLayer(processing.run("native:pointonsurface",
                                                 {'INPUT': layer_name,
                                                  'OUTPUT': 'memory:points_inaccessibility'})['OUTPUT'])

    def point_xy(self):
        """Создание временного слоя с координатами X,Y в WGS84: Создание файла привязки"""
        self.instance.addMapLayer(processing.run("native:addxyfields",
                                                 {'CRS': QgsCoordinateReferenceSystem('EPSG:4326'),
                                                  'INPUT': 'points_inaccessibility',
                                                  'OUTPUT': 'memory:points_xy'})['OUTPUT'])

    def file_create(self):
        """Подготовка к созданию файла привязки"""
        with open(f"{os.path.dirname(__file__)}/working files/filenames.json", "r") as file:
            filenames = json.load(file)
            if len(filenames) != 0:
                for filename in filenames:
                    self.rename_file(filename)
                    self.val += self.step
                    self.dlg.progressBar.setValue(self.val)

    def rename_file(self, filename):
        """Переименование исходных файлов, для приведения их названия к общему шаблону"""
        old_name = filename.split('/')[len(filename.split('/')) - 1]
        new_name = f"{filename.replace(f'{old_name}', '')}" \
                   f"{filename.split('/')[len(filename.split('/')) - 1].replace(' ', '').upper()}"
        os.rename(f"{filename}", f"{new_name}")
        self.data_extract(new_name.split('/')[len(new_name.split('/')) - 1], new_name)

    def data_extract(self, name, new_name):
        """Извлечение информации о номере квартала и выдела"""
        kv, vd, pvd = 0, 0, 0
        if "KW" in name:
            if "VD" in name:
                kv = re.search(r'KW[0-9]{1,4}', name).group(0).replace(f'KW', '')
                vd = re.search(r'VD[0-9]{1,4}', name).group(0).replace(f'VD', '')
                if re.search(r'PVD[0-9]{1,4}', name) is not None:
                    pvd = re.search(r'PVD[0-9]{1,4}', name).group(0).replace(f'PVD', '')
        elif "KV" in name:
            if "VD" in name:
                kv = re.search(r'KV[0-9]{1,4}', name).group(0).replace(f'KV', '')
                vd = re.search(r'VD[0-9]{1,4}', name).group(0).replace(f'VD', '')
                if re.search(r'PVD[0-9]{1,4}', name) is not None:
                    pvd = re.search(r'PVD[0-9]{1,4}', name).group(0).replace(f'PVD', '')
        elif "КВАРТ" in name:
            if "ВЫД" in name:
                kv = re.search(r'КВАРТ[А-Я]*[0-9]{1,4}', name).group(0).replace(f'КВАРТАЛ', '')
                vd = re.search(r'ВЫД[А-Я]*[0-9]{1,4}', name).group(0).replace(f'ВЫДЕЛ', '')
                if re.search(r'ПОДВ[А-Я]*[0-9]{1,4}', name) is not None:
                    pvd = re.search(r'ПОДВ[А-Я]*[0-9]{1,4}', name).group(0).replace(f'ПОДВЫДЕЛ', '')
        elif "КВ" in name:
            if "ВД" in name:
                kv = re.search(r'КВ[0-9]{1,4}', name).group(0).replace(f'КВ', '')
                vd = re.search(r'ВД[0-9]{1,4}', name).group(0).replace(f'ВД', '')
                if re.search(r'ПОДВ[0-9]{1,4}', name) is not None:
                    pvd = re.search(r'ПОДВ[0-9]{1,4}', name).group(0).replace(f'ПОДВ', '')
        # TODO: Возможно стоит добавить сообщение о том, что название фото не соответствует требованиям
        self.output_file(new_name, kv, vd, pvd)

    def output_file(self, new_name, kv, vd, pvd):
        """Создание выходного файла .jpg"""
        if kv and vd is not 0:
            with open(f"{new_name}", "rb") as f:
                file_image = exifread.process_file(f)
                date_time = str(file_image['EXIF DateTimeOriginal'])
                output = f"{self.dlg.path.text()}/1_0_0_{kv}_{vd}_" \
                         f"{date_time.split(' ')[0].replace(':', '')}" \
                         f"_{date_time.split(' ')[1].replace(':', '')}_1.jpg"
                if pvd != 0:
                    output = f"{self.dlg.path.text()}/1_0_0_{kv}_{vd}00{pvd}_" \
                             f"{date_time.split(' ')[0].replace(':', '')}_" \
                             f"{date_time.split(' ')[1].replace(':', '')}_1.jpg"
            self.fields_data_extraction(date_time, new_name, output, kv, vd, pvd)

    def fields_data_extraction(self, date_time, new_name, output, kv, vd, pvd):
        """Создание данных для выходного файла json"""
        layer = self.instance.mapLayersByName("points_xy")[0]
        ind_kv, ind_vd, ind_pvd = None, None, None
        if 'KV' and 'VID' and 'PV' in layer.fields().names():
            ind_kv, ind_vd, ind_pvd = layer.dataProvider().fieldNameIndex('KV'), \
                layer.dataProvider().fieldNameIndex('VID'), layer.dataProvider().fieldNameIndex('PV')
        elif 'KW' and 'VD' and 'PVD' in layer.fields().names():
            ind_kv, ind_vd, ind_pvd = layer.dataProvider().fieldNameIndex('KW'), \
                layer.dataProvider().fieldNameIndex('VD'), layer.dataProvider().fieldNameIndex('PVD')
        elif 'KV' and 'SKNR' in layer.fields().names():
            ind_kv, ind_vd = layer.dataProvider().fieldNameIndex('KV'), layer.dataProvider().fieldNameIndex('SKNR')
        for feature in layer.getFeatures():
            if feature[ind_kv] == int(kv) and feature[ind_vd] == int(vd) and ind_pvd is None:
                self.wtiter_xy(feature, new_name, output, date_time, kv, vd, pvd)
            elif feature[ind_kv] == int(kv) and feature[ind_vd] == int(vd) and feature[ind_pvd] == int(pvd):
                self.wtiter_xy(feature, new_name, output, date_time, kv, vd, pvd)

    def wtiter_xy(self, feature, new_name, output, date_time, kv, vd, pvd):
        """Запись x,y координат в файл"""
        x, y, x_crs, y_crs = feature['x'], feature['y'], feature['x_crs'], feature['y_crs']
        self.copy_files(new_name, output)
        file_json(date_time, output, kv, vd, pvd, x, y, x_crs, y_crs,
                  self.wnd.Subject.text(), self.wnd.Forestry.text(), self.wnd.PrForestry.text())

    def comparison(self, slayer, kv, vd, zk_txt, vmr, mtip, dtg, amz1, skal1):
        """Создание ведомости о пропущенной фотофиксации в выделе"""
        txt = []
        coincidence = []
        with open(f"{os.path.dirname(__file__)}/working files/filenames.json", "r") as file:
            filenames = json.load(file)
            if len(filenames) != 0:
                for filename in filenames:
                    with open(f'{filename[:-3]}json', 'r') as json_file:
                        data = json.load(json_file)
                        kw = data['kv']
                        vid = data['vid']
                        if "00" in str(vid):
                            pv = int(str(vid).split("00")[1])
                        else:
                            pv = 0
                        if kw != 0 and vid != 0:
                            self.search_for_matches(slayer, kw, vid, kv, vd, coincidence)
                for feature in slayer.getFeatures():
                    if int(f"{feature[kv]}{feature[vd]}") not in coincidence:
                        txt.append(f"Квартал: {feature[kv]} выдел: {feature[vd]} подвыдел: {pv}\n")
                        txt.append(f"Категория земель: {feature[zk_txt]}\n")
                        txt.append(f"Порода: {feature[vmr]} Тип леса: {feature[mtip]} ТЛУ: {feature[dtg]}\n")
                        txt.append(f"Возраст: {feature[amz1]} Полнота: {feature[skal1]}\n")
                        txt.append(f"---------------------------------------------\n")
        statement(txt)

    def search_for_matches(self, slayer, kw, vid, kv, vd, coincidence):
        """Поиск совпадений № квартала и выдела: Процесс создания ведомости фотофиксации"""
        for feature in slayer.getFeatures():
            if feature[kv] == kw and feature[vd] == vid:
                coincidence.append(int(f"{kw}{vid}"))
                self.val += self.step
                self.dlg.progressBar.setValue(self.val)
        return coincidence

    def import_file(self):
        """Импорт файла привязки"""
        direct = QFileDialog.getOpenFileName(self.dlg, 'Открыть файл привязки', '', 'JSON file (*.json)')[0]
        if os.path.exists(direct):
            shutil.copy(f"{direct}", f"{self.plugin_dir}/working files/photo path.json")
            set_style(self.dlg.layerBox_1.itemData(self.dlg.layerBox_1.currentIndex()))
            self.dlg.layerBox_1.itemData(self.dlg.layerBox_1.currentIndex()).triggerRepaint()
            self.iface.messageBar().pushMessage("Файл путей импортирован", level=Qgis.Info)
            self.cancel()

    def export(self):
        """Сохранение файла с путями к файлам привязки"""
        try:
            if os.path.exists(f"{self.plugin_dir}/working files/photo path.json"):
                direct = QFileDialog.getSaveFileName(self.dlg, 'Сохранить как', '', 'JSON file (*.json)')[0]
                shutil.copy(f"{self.plugin_dir}/working files/photo path.json", f"{direct}")
                self.iface.messageBar().pushMessage("Файл путей экспортирован", level=Qgis.Info)
            else:
                message("Ошибка!", "Файл привязки ещё не создан, выполните фотопривязку")
        except FileNotFoundError:
            pass
        # self.cancel()

    def cancel(self):
        """Закрытие диалогового окна плагина"""
        self.dlg.close()
